import discord
from discord.ext import commands, tasks
from datetime import datetime, timezone
import os
import traceback

# -------------------------
# BOT CONFIGURATION
# -------------------------
try:
    DISCORD_TOKEN = os.getenv("MTM5NzAyNzIxMTM5OTI3MDQ2Mg.GGDb9x.4CEi0PHvF41n_fopnm1yPRZcvkF1w-j_ZaCEjQ")
    GUILD_ID = int(os.getenv("1384621027627372714"))
    CHANNEL_ID = int(os.getenv("1384621028877144098"))
    PREFIX = os.getenv("BOT_PREFIX", "!")
    UPDATE_INTERVAL = int(os.getenv("UPDATE_INTERVAL", "24"))
    if UPDATE_INTERVAL <= 0:
        raise ValueError("UPDATE_INTERVAL deve ser um inteiro positivo")
except (ValueError, TypeError) as e:
    print(f"ERRO: Configura√ß√£o inv√°lida de vari√°veis de ambiente: {e}")
    print("Certifique-se de definir DISCORD_TOKEN, GUILD_ID, CHANNEL_ID e UPDATE_INTERVAL no painel Secrets do Replit.")
    exit(1)
except Exception as e:
    print(f"ERRO: Falha ao carregar vari√°veis de ambiente: {e}")
    exit(1)

# -------------------------
# BOT SETUP
# -------------------------
intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
intents.members = True  # Necess√°rio para detectar mudan√ßas de booster

bot = commands.Bot(command_prefix=PREFIX, intents=intents, help_command=None, case_insensitive=True)

# Global variables
last_update = None
ranking_message = None
ranking_data = []

# -------------------------
# UTILITY FUNCTIONS
# -------------------------
async def log_error(error_msg, exception=None):
    """Registra erros com formata√ß√£o adequada."""
    print(f"ERRO: {error_msg}")
    if exception:
        print(f"Detalhes da exce√ß√£o: {exception}")
        traceback.print_exc()

def calculate_boost_duration(premium_since):
    """Calcula a dura√ß√£o do boost em meses e dias."""
    if not premium_since:
        return 0, 0

    delta = datetime.now(timezone.utc) - premium_since
    total_days = delta.days
    months = total_days // 30
    remaining_days = total_days % 30
    return months, remaining_days

# -------------------------
# RANKING SYSTEM
# -------------------------
def build_ranking_embed(page: int, per_page=10):
    """Constr√≥i o embed de ranking com pagina√ß√£o."""
    try:
        total_pages = max(1, (len(ranking_data) - 1) // per_page + 1)
        page = max(0, min(page, total_pages - 1))  # Garante que a p√°gina est√° nos limites
        embed = discord.Embed(
            title="üèÜ Ranking de Boosters",
            color=discord.Color.purple(),
            timestamp=datetime.now(timezone.utc)
        )

        if not ranking_data:
            embed.description = "üöÄ Nenhum booster ativo no momento!"
            embed.add_field(
                name="‚ÑπÔ∏è Informa√ß√£o",
                value="Fa√ßa boost no servidor para aparecer no ranking!",
                inline=False
            )
        else:
            start = page * per_page
            end = start + per_page
            page_items = ranking_data[start:end]

            description = ""
            for i, (member, months, days) in enumerate(page_items, start=start + 1):
                medal = ""
                if i == 1:
                    medal = "ü•á "
                elif i == 2:
                    medal = "ü•à "
                elif i == 3:
                    medal = "ü•â "

                duration_text = f"{months} meses e {days} dias" if months > 0 else f"{days} dias"
                description += f"{medal}**{i}.** {member.mention} ‚Äî {duration_text}\n"

            embed.description = description

        footer_text = f"P√°gina {page + 1} de {total_pages}"
        if last_update:
            footer_text += f" ‚Ä¢ √öltima atualiza√ß√£o: {last_update.strftime('%d/%m/%Y %H:%M UTC')}"

        embed.set_footer(text=footer_text)
        return embed

    except Exception as e:
        print(f"ERRO: Erro ao construir embed de ranking: {e}")
        traceback.print_exc()
        error_embed = discord.Embed(
            title="‚ùå Erro",
            description="Ocorreu um erro ao construir o ranking. Tente novamente.",
            color=discord.Color.red()
        )
        return error_embed

async def update_ranking_data():
    """Atualiza os dados do ranking a partir do servidor do Discord."""
    global ranking_data, last_update

    try:
        guild = bot.get_guild(GUILD_ID)
        if not guild:
            await log_error(f"Servidor com ID {GUILD_ID} n√£o encontrado")
            return False

        boosters = guild.premium_subscribers
        if not boosters:
            ranking_data = []
            last_update = datetime.now(timezone.utc)
            return True

        new_ranking_data = []
        for member in boosters:
            try:
                if member.premium_since:
                    months, days = calculate_boost_duration(member.premium_since)
                    new_ranking_data.append((member, months, days))
            except Exception as e:
                await log_error(f"Erro ao processar membro {member.id}", e)
                continue

        new_ranking_data.sort(key=lambda x: (x[1], x[2]), reverse=True)

        ranking_data = new_ranking_data
        last_update = datetime.now(timezone.utc)

        print(f"Ranking atualizado com sucesso. Encontrados {len(ranking_data)} boosters.")
        return True

    except discord.errors.Forbidden as e:
        await log_error("Bot sem permiss√µes para acessar o servidor", e)
        return False
    except discord.errors.HTTPException as e:
        await log_error("Erro na API do Discord durante atualiza√ß√£o do ranking", e)
        return False
    except Exception as e:
        await log_error("Erro ao atualizar dados do ranking", e)
        return False

async def send_or_edit_ranking():
    """Envia nova mensagem de ranking ou edita a existente."""
    global ranking_message

    try:
        if not await update_ranking_data():
            return False

        channel = bot.get_channel(CHANNEL_ID)
        if not isinstance(channel, discord.TextChannel):
            await log_error(f"Canal {CHANNEL_ID} n√£o √© um canal de texto")
            return False

        embed = build_ranking_embed(0)
        view = RankingView(page=0)

        if ranking_message:
            try:
                await ranking_message.fetch()  # Verifica se a mensagem ainda existe
                await ranking_message.edit(embed=embed, view=view)
                print("Mensagem de ranking atualizada com sucesso.")
                return True
            except discord.NotFound:
                print("Mensagem de ranking anterior n√£o encontrada, criando nova...")
                ranking_message = None
            except discord.Forbidden:
                await log_error("Bot sem permiss√£o para editar mensagem")
                return False
            except discord.HTTPException as e:
                await log_error("Erro na API do Discord ao editar mensagem", e)
                return False

        try:
            ranking_message = await channel.send(embed=embed, view=view)
            print("Nova mensagem de ranking enviada com sucesso.")
            return True
        except discord.Forbidden:
            await log_error("Bot sem permiss√£o para enviar mensagens no canal")
            return False
        except discord.HTTPException as e:
            await log_error("Erro na API do Discord ao enviar mensagem", e)
            return False

    except Exception as e:
        await log_error("Erro cr√≠tico em send_or_edit_ranking", e)
        return False

# -------------------------
# DISCORD UI VIEW
# -------------------------
class RankingView(discord.ui.View):
    def __init__(self, page=0):
        super().__init__(timeout=86400)  # Timeout de 24 horas
        self.page = page

    @discord.ui.button(label="‚¨ÖÔ∏è Voltar", style=discord.ButtonStyle.secondary)
    async def back_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        try:
            if self.page > 0:
                self.page -= 1

            embed = build_ranking_embed(self.page)
            await interaction.response.edit_message(embed=embed, view=self)
        except discord.errors.InteractionResponded:
            pass  # Ignora se a intera√ß√£o j√° foi respondida
        except Exception as e:
            await log_error("Erro na intera√ß√£o do bot√£o voltar", e)
            try:
                await interaction.response.send_message(
                    "‚ùå Erro ao navegar. Tente novamente.",
                    ephemeral=True
                )
            except:
                pass

    @discord.ui.button(label="‚û°Ô∏è Avan√ßar", style=discord.ButtonStyle.secondary)
    async def next_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        try:
            max_page = max(0, (len(ranking_data) - 1) // 10)
            if self.page < max_page:
                self.page += 1

            embed = build_ranking_embed(self.page)
            await interaction.response.edit_message(embed=embed, view=self)
        except discord.errors.InteractionResponded:
            pass
        except Exception as e:
            await log_error("Erro na intera√ß√£o do bot√£o avan√ßar", e)
            try:
                await interaction.response.send_message(
                    "‚ùå Erro ao navegar. Tente novamente.",
                    ephemeral=True
                )
            except:
                pass

    @discord.ui.button(label="‚è™ In√≠cio", style=discord.ButtonStyle.primary)
    async def first_page_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        try:
            self.page = 0
            embed = build_ranking_embed(self.page)
            await interaction.response.edit_message(embed=embed, view=self)
        except discord.errors.InteractionResponded:
            pass
        except Exception as e:
            await log_error("Erro na intera√ß√£o do bot√£o in√≠cio", e)
            try:
                await interaction.response.send_message(
                    "‚ùå Erro ao navegar. Tente novamente.",
                    ephemeral=True
                )
            except:
                pass

    @discord.ui.button(label="üîÑ Atualizar", style=discord.ButtonStyle.success)
    async def refresh_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        try:
            await interaction.response.defer(ephemeral=True)

            if await update_ranking_data():
                embed = build_ranking_embed(0)
                await interaction.followup.send(
                    embed=embed,
                    ephemeral=True
                )
            else:
                await interaction.followup.send(
                    "‚ùå Erro ao atualizar dados. Tente novamente mais tarde.",
                    ephemeral=True
                )
        except Exception as e:
            await log_error("Erro na intera√ß√£o do bot√£o atualizar", e)
            try:
                await interaction.followup.send(
                    "‚ùå Erro ao atualizar. Tente novamente.",
                    ephemeral=True
                )
            except:
                pass

# -------------------------
# BOT EVENTS
# -------------------------
@bot.event
async def on_ready():
    print(f"ü§ñ Bot conectado como {bot.user}")
    print(f"üìä Monitorando servidor ID: {GUILD_ID}")
    print(f"üì∫ Canal de ranking ID: {CHANNEL_ID}")

    try:
        await send_or_edit_ranking()
    except Exception as e:
        await log_error("Erro na atualiza√ß√£o inicial do ranking", e)

    if not update_booster_ranking.is_running():
        update_booster_ranking.change_interval(hours=UPDATE_INTERVAL)
        update_booster_ranking.start()
        print(f"‚è∞ Atualiza√ß√µes autom√°ticas configuradas para cada {UPDATE_INTERVAL} horas")

@bot.event
async def on_member_update(before, after):
    if before.premium_since != after.premium_since:
        print(f"Status de booster alterado para {after.name}")
        try:
            await send_or_edit_ranking()
        except Exception as e:
            await log_error("Erro ao atualizar ranking ap√≥s mudan√ßa de booster", e)

@bot.event
async def on_error(event, *args, **kwargs):
    await log_error(f"Erro do bot no evento {event}")

@bot.event
async def on_command_error(ctx, error):
    if isinstance(error, commands.CommandNotFound):
        return

    await log_error(f"Erro de comando: {error}")

    try:
        await ctx.send(
            f"‚ùå Ocorreu um erro ao executar o comando: `{error}`\n"
            f"Use `{PREFIX}helpboost` para ver os comandos dispon√≠veis."
        )
    except:
        pass

# -------------------------
# TASKS
# -------------------------
@tasks.loop(hours=UPDATE_INTERVAL)
async def update_booster_ranking():
    print("‚è∞ Executando atualiza√ß√£o autom√°tica do ranking...")
    try:
        success = await send_or_edit_ranking()
        if success:
            print("‚úÖ Ranking atualizado automaticamente com sucesso")
        else:
            print("‚ùå Falha na atualiza√ß√£o autom√°tica do ranking")
    except Exception as e:
        await log_error("Erro na atualiza√ß√£o peri√≥dica do ranking", e)

# -------------------------
# COMMANDS
# -------------------------
@bot.command(name='helpboost', aliases=['help', 'ajuda'])
async def help_command(ctx):
    try:
        embed = discord.Embed(
            title="üìú Ajuda - Bot de Ranking de Boosters",
            color=discord.Color.blue(),
            timestamp=datetime.now(timezone.utc)
        )

        embed.add_field(
            name="üéØ Sobre",
            value="Este bot monitora e exibe um ranking dos boosters do servidor, "
                  "ordenados por tempo de boost.",
            inline=False
        )

        embed.add_field(
            name="üîò Bot√µes de Navega√ß√£o",
            value="‚¨ÖÔ∏è **Voltar** - P√°gina anterior\n"
                  "‚û°Ô∏è **Avan√ßar** - Pr√≥xima p√°gina\n"
                  "‚è™ **In√≠cio** - Primeira p√°gina\n"
                  "üîÑ **Atualizar** - Atualiza o ranking (s√≥ para voc√™)",
            inline=False
        )

        embed.add_field(
            name="üí¨ Comandos",
            value=f"`{PREFIX}helpboost` - Exibe esta ajuda\n"
                  f"`{PREFIX}help` - Alias para helpboost\n"
                  f"`{PREFIX}ajuda` - Alias para helpboost\n"
                  f"`{PREFIX}status` - Exibe o status do bot (somente administradores)",
            inline=False
        )

        embed.add_field(
            name="‚öôÔ∏è Configura√ß√£o",
            value=f"Atualiza√ß√£o autom√°tica: {UPDATE_INTERVAL} horas\n"
                  f"√öltima atualiza√ß√£o: {last_update.strftime('%d/%m/%Y %H:%M UTC') if last_update else 'Nunca'}",
            inline=False
        )

        embed.set_footer(text="Bot desenvolvido para monitoramento de boosters")

        await ctx.send(embed=embed)

    except Exception as e:
        await log_error("Erro no comando de ajuda", e)
        await ctx.send(
            f"‚ùå Erro ao exibir ajuda. Use `{PREFIX}helpboost` para tentar novamente."
        )

@bot.command(name='status')
@commands.has_permissions(administrator=True)
async def status_command(ctx):
    try:
        guild = bot.get_guild(GUILD_ID)
        guild_name = guild.name if guild else "Servidor n√£o encontrado"
        booster_count = len(guild.premium_subscribers) if guild else 0

        embed = discord.Embed(
            title="üìä Status do Bot",
            color=discord.Color.green(),
            timestamp=datetime.now(timezone.utc)
        )

        embed.add_field(name="üè† Servidor", value=guild_name, inline=True)
        embed.add_field(name="üöÄ Boosters Ativos", value=str(booster_count), inline=True)
        embed.add_field(name="‚è∞ Intervalo de Atualiza√ß√£o", value=f"{UPDATE_INTERVAL}h", inline=True)
        embed.add_field(
            name="üïê √öltima Atualiza√ß√£o",
            value=last_update.strftime('%d/%m/%Y %H:%M UTC') if last_update else "Nunca",
            inline=True
        )
        embed.add_field(name="üü¢ Status", value="Online", inline=True)
        embed.add_field(name="üì± Lat√™ncia", value=f"{round(bot.latency * 1000)}ms", inline=True)

        await ctx.send(embed=embed)

    except Exception as e:
        await log_error("Erro no comando status", e)
        await ctx.send("‚ùå Erro ao obter status do bot.")

@bot.command()
async def ping(ctx):
    await ctx.send(f"Pong! Lat√™ncia: {round(bot.latency * 1000)}ms")

# -------------------------
# BOT START
# -------------------------
if __name__ == "__main__":
    bot.run(DISCORD_TOKEN)